Four: 3b1b

Combine files when done

test if input is svg...
if yes continue:
else:
do file svg
    convrty image to edge, then modify it
    # maybe bitmap
    maybe save to svg.. if not skip svg load, and convert to fonction

after animation either 3b1b or circles
this, plot animation, circle postion changes and angle of rad changes, add tip of las arrow to plot

svg:
extend all paths
for path in paths:
decode path
p_total.append[path]

convert svg?
get img svg y
get curves y
for each curve get fft y
comb curves y

for each freq disp, show time varimg abs
pos, vs time
show pos variang
let circles run with initial f
do plot circ
plot sum f
save animation

----------------------------------------------------

Four spectro

use spect to view, maybe just save,
use yt for live waveform, save data to np array for spextrograme at end
https://www.youtube.com/watch?v=TJGlxdW7Fb4&ab_channel=SteveBrunton
https://www.youtube.com/watch?v=AShHJdSIxkY&t=1s&ab_channel=MarkJay
get audio evey sample, save raw data to np array, then do fft ard rest yt

loop to set lines
show image of pic in

# def test_pos(val):
#     i = 0
#     for f in frequency:
#         if val > f:
#             break
#         i += 1
#     return frequency[i - 1]
*1 for feq
seg += get_freq: get s_wave
then for duration/pixel
seg_tot[duration_pix: duration_pix + chuck] = seg_tot
 after all read from file, then plot,... same as if from live except stream

 sine:
 # s_wav = freq  # sine(freq)
    # wav = s_wav.to_audio_segment(duration_per_pix, am_scale*pix_val)
    # wav = wav.fade_in(0.1 * duration_per_pix).fade_out(0.1 * duration_per_pix)

do
get image, yes
loop though image: yes
get sinedata
save sinedata
save to file, then
plot live below

while mike yes
get audio: yes
decode yes
fft
save to array yes
plot decode and live,
plot 5 largest fequcy on dif subplot, diff colors
do spect, yes
save spect

audio to image

    #     # gen tone for each sine
    #     freq_ls = max_freq(freq_fft, 5)
    #     # sum_x_fr = sum(freq_ls)
    #     for fr in freq_ls:
    #         line_fr = 2 * np.pi * np.arrage(rate*duration_per_pix) * fr/rate
    #         ax_sine.plot(line_fr, np.sin(line_fr))
    #
    #     total_list = np.vstack(total_list, data_int)
    #
    #     if total_list.shape[0] > 500:  # max size
    #         break
    #     plot_img(total_list)
    #
    # spec = spectrogram(total_list)
    # save spec
    # plt.show(spec)
img_obj = Image.fromarray(total_list)
    # write to pic_file
    process_image(img_obj)


def process_image(img_o):
    """turn spec image into real image"""
    # save
    img_o.save(return_img)

    # line, = ax[0, 0].plot(x_data, np.random.rand(Chuck))
# ax[0, 0].set_xlim(0, Chuck)
# ax[0, 0].set_ylim(0, 255)
#
# line2, = ax[1, 0].plot(x_data, np.random.rand(Chuck))
# ax[1, 0].set_xlim(0, Chuck)
# ax[1, 0].set_ylim(0, 255)